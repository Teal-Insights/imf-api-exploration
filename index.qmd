---
title: "IMF Data SDMX API exploration"
format: gfm
---

## Problem Statement

The IMF has recently released a [new API](https://datasupport.imf.org/knowledge?id=knowledge_category&sys_kb_id=d41858e747294ad8805d07c4f16d43e0&category_id=9959b2bc1b6391903dba646fbd4bcb6a) that returns data in [SDMX 3.0](https://sdmx.org/standards-2/) format, with support for (SDMX-JSON)[https://github.com/sdmx-twg/sdmx-json].

The way the IMF recommends you use this API is via the `rsdmx` library. However, this poses a problem for some governmental and corporate users, because `rsdmx` is a GPL3-licensed library, and GPL3 creates liability and compliance issues that these organizations prefer not to deal with. So, the [econdataverse](https://econdataverse.org) team proposes to build its own, dedicated, MIT-licensed library for retrieving data from the new IMF API.

This notebook contains some initial explorations toward that end.

### Goal

Build a foundational package with all-purpose functions for getting the full range of data available through the API. (We'll skip implementing metadata fetching functions for now.)

### Questions to answer

- How do we list available datasets?
- How do we get structure/parameters of a dataset?
- How do we get codelist for a given parameter?
- Once we have codelists, how do we query for datasets?

## Prior art

### Example IMF API workflow

The README for [imfr](https://github.com/christophergandrud/imfr) lays out the basic workflow for working with an SDMX-style API.

### Example `econdataverse` package

The repo for [r-wbids](https://github.com/Teal-Insights/r-wbids/tree/main/R) illustrates our project code conventions.

### Function names

Broadly speaking, we typically have `list` functions and `get` functions that expose to users, plus an internal `perform_request` function that handles API calling, and helpers for validation and error handling. For example, user-facing functions might include:

- `imf_get`
- `imf_list_indicators`
- `imf_list_geographies`

## API overview

### Authentication

This is a public API. The spec refers to providing an API key, either as a header (`Ocp-Apim-Subscription-Key`) or a query parameter (`subscription-key`), but this seems to be an Azure key for use by administrators only. End users do not need this key to call the API, and we don't need to support it.

### URL format

``` {r}
library(glue)  # We can use the `glue` function to populate template strings

base_url <- "https://api.imf.org/external/sdmx/3.0"
structure_url <- "{base_url}/structure/{structureType}/{agencyID}/{resourceID}/{version}"
availability_url <- "{base_url}/availability/{context}/{agencyID}/{resourceID}/{version}/{key}/{componentID}"
data_url <- "{base_url}/data/{context}/{agencyID}/{resourceID}/{version}/{key}"
```

### Headers

Since we want JSON rather than XML output (because JSON is easier to work with in R and Python), we will also add an "Accept" header:

``` {r}
json_header <- "application/json"
```

And as a matter of courtesy, we will add a "User-Agent" to indicate what application sent the request:

``` {r}
user_agent <- "r-imf"  # or whatever name we choose
```

### Request parameters

``` {r}
c <- "c[IFS_Flag]=True"  # "constrains" output to former IFS datasets
```

## Exploration plan

### "/structure"

Returns structural information required for constructing queries.

- "dataflow" (describing specific datasets)
- "datastructure" (DSDs - defining the dimensions and attributes of a dataset)
- "codelist" (Supports wildcards `*`, other query methods like `full`, `allstubs`, `children`, `parents`, `all`, `none`)

### "/data"

To retrieve the actual statistical time series and observations. Filterable by context, agency, resource, version, and `key` patterns (dimension values, with wildcards). Supports time-based filtering (`updatedAfter`, `firstNObservations`, `lastNObservations`), various data packaging options (`TIME_PERIOD` for time series, `AllDimensions` for flat views), and inclusion of history (`includeHistory`).

## Stuff to skip for now

### "/availability"

For validating potential data queries. Returns a "Constraint" object that defines the exact "cubeRegions" and valid dimension values for a given data query pattern.

#### Example `/availability` query

``` {r}
library(httr2)

context <- "dataflow"
agencyID <- "IMF.STA"
resourceID <- "CPI"
version <- "+"
key <- "USA.CPI.*.IX.M"
componentID <- "COICOP_1999"

# IMF SDMX API endpoint for CPI dataflow structure
url <- glue(availability_url, base_url, context, agencyID, resourceID, version, key, componentID)

# Create and execute the request
response <- request(url) |>
  req_headers(
    "Accept" = json_header,
    "User-Agent" = user_agent
  ) |>
  req_cache(tempdir()) |>
  req_perform()

# Check the response status
print(paste("Status:", resp_status(response)))

# Get the response body as text (JSON format)
content <- resp_body_string(response)

# Print first 1000 characters to preview
cat("Response preview:\n")
cat(substr(content, 1, 1000))
cat("\n...\n")

# Optionally save the full response to a file
writeLines(content, "imf_cpi_dataflow_availability.json")
cat("Full response saved to: imf_cpi_dataflow_availability.json\n")
```

### "/metadata"

Descriptive information about datasets, indicators, etc.; we will ignore for now.

## Step-by-step workflow

### Method 1: Using the structure query to find the indicator codelist

This is the most reliable way to get the comprehensive list of available indicators, as it directly retrieves the codelist that defines them.

1.  **Identify a relevant Dataflow or Data Structure:**
    From the `get-data` and `get-availability` examples, we see `resourceID` like `CPI` (Consumer Price Index) from `agencyID` `IMF.STA`. This `CPI` is likely a `dataflow`.

2.  **Query the Dataflow to find its associated Data Structure Definition (DSD):**
    A `dataflow` defines what data is available, and it references a `datastructure` which defines the dimensions (like "indicator").

    *   **Endpoint:** `/structure/{structureType}/{agencyID}/{resourceID}/{version}`
    *   **Parameters:**
        *   `structureType`: `dataflow`
        *   `agencyID`: `IMF.STA` (or `*` to find all dataflows from all agencies)
        *   `resourceID`: `CPI` (or `*` to find all dataflows)
        *   `version`: `+` (for the latest stable version)
        *   `detail`: `full` (to get all details, including references)
        *   `references`: `children` or `all` (to ensure the referenced DSD is returned)

    **Example Request:**
    `GET https://api.imf.org/external/sdmx/3.0/structure/dataflow/IMF.STA/CPI/+?detail=full&references=children`

    **What to look for in the response:**
    In the JSON response, navigate to `data.dataflows[0].links`. You should find a link with `title: "DataStructureDefinition"` and a `urn` like `urn:sdmx:org.sdmx.infomodel.datastructure.DataStructure=IMF:ECOFIN_DSD(1.2)`. Extract the `agencyID`, `resourceID`, and `version` of this Data Structure Definition (e.g., `IMF`, `ECOFIN_DSD`, `1.2`).
    
## Jenny's Exploration

### `structure` endpoint

Dimensions: 

- `json_object["data"]["dataStructures"][0]["dataStructureComponents"]["dimensionList"]["dimensions"]`
- `json_object["data"]["dataStructures"][0]["dataStructureComponents"]["dimensionList"]["timeDimensions"]`

```{r}
library(httr2)
library(glue)
library(dplyr)
library(tidyverse)

# 1. Query the Dataflow
base_url <- "https://api.imf.org/external/sdmx/3.0"
structureType <- "dataflow"
agencyID <- "IMF.STA"
resourceID <- "CPI" # Consumer Price Index
version <- "+" # This will probably always be the same

json_header <- "application/json"
user_agent <- "r-imf-explore/0.0.1" # Telling the API who we are

url <- glue("{base_url}/structure/{structureType}/{agencyID}/{resourceID}/{version}?detail=full&references=children")
cat(url, "\n")

response <- request(url) |>
  req_headers(
    "Accept" = json_header,
    "User-Agent" = user_agent
  ) |>
  req_cache(tempdir()) |>
  req_perform()

# Check the response status
print(paste("Status:", resp_status(response)))

# Get the response body as text (JSON format)
content <- resp_body_string(response)

# Print first 1000 characters to preview
cat("Response preview:\n")
cat(substr(content, 1, 1000))
cat("\n...\n")

# Optionally save the full response to a file
writeLines(content, "imf_cpi_dataflow_structure.json")
cat("Full response saved to: imf_cpi_dataflow_structure.json\n")
```

``` {r}
# 2. Extract Associated Data Structure Definitions
# Parse the json file into nested R list
j <- resp_body_json(response, simplifyVector = TRUE)

# Extract urn, agency ID, resource ID, and version for Data Structure Definition (DSD)
dsd.urn <- j$data$dataflows$structure
dsd.agencyID <- j$data$dataStructures$agencyID
dsd.resourceID <- j$data$dataStructures$id
dsd.version <- j$data$dataStructures$version
dsd.table <- dplyr::tibble(
  dsd.urn = dsd.urn,
  dsd.agencyID = dsd.agencyID,
  dsd.resourceID = dsd.resourceID,
  dsd.version = dsd.version
) 

# Extract ID, position, and urn for Dimensions
dims <- j$data$dataStructures$dataStructureComponents$dimensionList
dimensions.ID <- dims$dimensions[[1]][["id"]]
dimensions.position <- dims$dimensions[[1]][["position"]]
dimensions.urn <- dims$dimensions[[1]][["conceptIdentity"]]
dim.table <- dplyr::tibble(
  dim.id = dimensions.ID,
  dim.position = dimensions.position,
  dim.urn = dimensions.urn
)

# Generate the output table
dsd.table
dim.table
```

3.  **Query the Data Structure Definition (DSD) to find the Indicator Dimension's Codelist:**
    The DSD defines all the dimensions. One of these dimensions will represent the "indicator".

    *   **Endpoint:** `/structure/{structureType}/{agencyID}/{resourceID}/{version}`
    *   **Parameters:**
        *   `structureType`: `datastructure`
        *   `agencyID`: (from previous step, e.g., `IMF`)
        *   `resourceID`: (from previous step, e.g., `ECOFIN_DSD`)
        *   `version`: (from previous step, e.g., `1.2`)
        *   `detail`: `full`
        *   `references`: `all` (this is crucial to get the referenced codelists)

    **Example Request (using values found in step 2):**
    `GET https://api.imf.org/external/sdmx/3.0/structure/datastructure/IMF/ECOFIN_DSD/1.2?detail=full&references=all`

    **What to look for in the response:**
    In the JSON response, look at `data.dataStructures[0].dimensions`. You'll typically find a dimension with an `id` like `INDICATOR` or `REF_INDICATOR`. This dimension will have a `representation` property, which might directly reference a `codelist` URN (e.g., `urn:sdmx:org.sdmx.infomodel.codelist.Codelist=IMF:CL_INDICATOR(1.0)`). Extract the `agencyID`, `resourceID`, and `version` of this Codelist (e.g., `IMF`, `CL_INDICATOR`, `1.0`).

Jenny's Exploration
```{r}
# 1. Query the Data Structure Definition (DSD)
structureType <- "datastructure"
url <- glue("{base_url}/structure/{structureType}/{dsd.agencyID}/{dsd.resourceID}/{dsd.version}?detail=full&references=all")
cat(url, "\n")

response <- request(url) |>
  req_headers(
    "Accept" = json_header,
    "User-Agent" = user_agent
  ) |>
  req_cache(tempdir()) |>
  req_perform()

# Check the response status
print(paste("Status:", resp_status(response)))

# Get the response body as text (JSON format)
content <- resp_body_string(response)

# Print first 1000 characters to preview
cat("Response preview:\n")
cat(substr(content, 1, 1000))
cat("\n...\n")

# Optionally save the full response to a file
writeLines(content, "imf_cpi_dataflow_availability.json")
cat("Full response saved to: imf_cpi_dataflow_availability.json\n")

# 2. Extract Associated Data Structure Definitions
# Parse the json file into nested R list
j <- resp_body_json(response, simplifyVector = TRUE)

codelists_to_keep <- c(
  "CL_INDEX_TYPE",
  "CL_COUNTRY",
  "CL_COICOP_1999",
  "CL_CPI_TYPE_OF_TRANSFORMATION",
  "CL_FREQ"
)

# Filter and keep only relevant columns
codelist.table <- j$data$codelists %>%
  filter(id %in% codelists_to_keep) %>%
  select(
    name,
    agencyID,
    resourceID = id,
    version
  )

codelist.table
```
4.  **Query the Indicator Codelist:**
    This final query will give you the actual list of indicators.

    *   **Endpoint:** `/structure/{structureType}/{agencyID}/{resourceID}/{version}`
    *   **Parameters:**
        *   `structureType`: `codelist`
        *   `agencyID`: (from previous step, e.g., `IMF`)
        *   `resourceID`: (from previous step, e.g., `CL_INDICATOR`)
        *   `version`: (from previous step, e.g., `1.0`)
        *   `detail`: `full` (to get all the codes within the codelist)

    **Example Request (using values found in step 3):**
    `GET https://api.imf.org/external/sdmx/3.0/structure/codelist/IMF/CL_INDICATOR/1.0?detail=full`

    **What you get:**
    The JSON response will contain `data.codeLists[0].codes`. Each object in this array will have an `id` (the indicator code) and `name` (the indicator's human-readable name), along with `description`. This is your list of indicators.

```{r}
# 1. Query the Codelist
structureType <- "codelist"
url.table <- codelist.table %>%
  mutate(
    url = glue("{base_url}/structure/{structureType}/{agencyID}/{resourceID}/{version}?detail=full")
  )

fetch_codelist_json <- function(url) {
  response <- request(url) |>
  req_headers(
    "Accept" = json_header,
    "User-Agent" = user_agent
  ) |>
  req_cache(tempdir()) |>
  req_perform()
  return(response)
}

response.table <- url.table %>%
  mutate(
    resp   = map(url, fetch_codelist_json),
    status = map_int(resp, resp_status),
    text   = map_chr(resp, resp_body_string),
    json   = map(resp, ~ resp_body_json(.x, simplifyVector = TRUE))
  )

response.table$json[1]



```

---

### Method 2: Using the data availability query (for available values for a specific context)

This method is useful if you already know the `dataflow` (like `CPI`) and want to see what specific values (indicators) are available for a given `key` pattern.

*   **Endpoint:** `/availability/{context}/{agencyID}/{resourceID}/{version}/{key}/{componentID}`
*   **Parameters:**
    *   `context`: `dataflow`
    *   `agencyID`: `IMF.STA` (or `*`)
    *   `resourceID`: `CPI` (or `*` if you want indicators across all dataflows, but this could return a massive, less useful result)
    *   `version`: `+`
    *   `key`: This is where you specify the partial key. If `USA.CPI.*.IX.M` means the indicator is the third segment, you'd use a pattern like `*.*.*.*.*.*` or `USA.CPI.*.IX.M` (if you are only interested in indicators for that specific series pattern). To get *all* indicators for the `CPI` dataflow, you might try `*` or a more generic pattern covering all dimensions of that DSD, e.g., `*.*.*.*.*.*` if the DSD has 6 dimensions, and the indicator is one of them.
    *   `componentID`: This is the crucial part. It should be the ID of the dimension that represents the indicator. Based on common SDMX practices and the `/data` endpoint's example (`USA.CPI.*.IX.M`), the indicator is likely in the third position and its dimension ID is commonly `INDICATOR`. So, you'd use `INDICATOR` here.

**Example Request:**
`GET https://api.imf.org/external/sdmx/3.0/availability/dataflow/IMF.STA/CPI/+/USA.CPI.*.IX.M/INDICATOR`

**What you get:**
The response will be a `dataConstraint` object (`data.dataConstraints[0]`). Inside `cubeRegions[0].components`, you'll find the `id` of the dimension (e.g., `INDICATOR`) and a list of `values` that are available for that specific dimension given the `key` filter. These `values` would be your available indicators for that context.

**Caveat:** The example for `componentID` in the OpenAPI spec (`COICOP_1999`) is slightly confusing as it looks like a value, not a dimension ID. However, the description states "The ID of the dimension for which to obtain availability information." so `INDICATOR` is the logical parameter to use.

---

**In summary, for a comprehensive list of all defined indicators (like `CPI`, `GDP`, etc.) regardless of current data availability, use Method 1 (Structure Queries). For a list of indicators that *actually have data* for a specific series pattern, use Method 2 (Data Availability).**

## Kweku's Summary

### Questions to answer
- How do we list available datasets?
  * **Example dataset:** `available_datasets.json`
  
  * **Endpoint:** `{base_url}/structure/{structureType}/{agencyID}/{resourceID}/{version}`
  
  * **Request Parameters:** 
    * structureType: `dataflow`
    * agencyID: `IMF.STA`
    * resourceID: `*`
    * version: `+`

  * **Request URL:** `https://api.imf.org/external/sdmx/3.0/structure/dataflow/IMF.STA/*/+`

  **What you get:**

  In the JSON response, `data.dataflows` is an array of objects and **each** object contains the `name` and `id` of a **single** dataset. 
  
  All available dataset names and ids can be obtained from the `dataflows` array.

- How do we get structure/parameters of a dataset?
  * **Example dataset:** `available_data_structures.json`

  * **Endpoint:** `{base_url}/structure/{structureType}/{agencyID}/{resourceID}/{version}`
  
  * **Request Parameters:** 
    * structureType: `datastructure`
    * agencyID: `IMF.STA`
    * resourceID: `*`
    * version: `+`

  * **Request URL:** `https://api.imf.org/external/sdmx/3.0/structure/datastructure/IMF.STA/*/+`

  **What you get:**

  In the JSON response, `data.datastructure` is an array of objects and **each** object contains a `dataStructureComponents` field which contains a `dimensionsList` object. 

  `dimensionList` has 2 main entries.

    1. `dimensions` which is a list of **dimensions**.
    2. `timedimensions` which is a list of **time dimensions**.
  
  **Issues:** 

  There is inconsistent mapping from an `id` and `name` of a **data structure** to its corresponding values in a **dataset**. 
  
- How do we get codelist for a given parameter?
  * **Example dataset:** `available_codelists.json`
  
  * **Endpoint:** `{base_url}/structure/{structureType}/{agencyID}/{resourceID}/{version}`
  
  * **Request Parameters:** 
    * structureType: `codelist`
    * agencyID: `IMF`
    * resourceID: `*`
    * version: `+`

  * **Request URL:** `https://api.imf.org/external/sdmx/3.0/structure/codelist/IMF/*/+`

  **What you get:**

  In the JSON response, `data.codelists` is an array of objects and **each** object contains an `id` that can be mapped to the **dimension** of a **dataset**. 
  
  This object contains a `codes` field, which is an array of codes for this codelist.
  
- How do we query data?
  * **Example dataset:** `available_data.json`
  
  * **Endpoint:** `{base_url}/data/{context}/{agencyID}/{resourceID}/{version}/{key}?dimensionsAtObservation={dimensions_at_observation}&attributes={attributes}&measures={measures}`
  
  * **Request Parameters:** 
    * context: `dataflow`
    * agencyID: `IMF.STA`
    * resourceID: `*`
    * version: `+`
    * key: `` 
      
      This is the series key of the dataset. It is a key to represent **slices** of the cube, 
      which can be thought of as segments of the dataset. 

      An example key is `USA.CPI.*.IX.M`.
    
    * dimensionsAtObservations: `TIME_PERIOD`
    * attributes: `dsd`
    * measures: `all`

  * **Example Request URL:** `https://api.imf.org/external/sdmx/3.0/data/dataflow/IMF.STA/*/+/USA.CPI.*.IX.M?dimensionsAtObservation=TIME_PERIOD&attributes=dsd&measures=all`

  **What you get:**
  
  In the JSON response, `data.dataSets` is an array of objects, and **each** object contains a `series` field which contains objects of `observations`. On the [IMF Data Explorer](https://data.imf.org/en/Data-Explorer) each observation corresponds to row-level time series.
  
  In the JSON reponse, `data.structures` contains column names and non-numerical data in the dataset.

  